<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>BLE Static Stack: Building an application separated from BlueNRG-1, BlueNRG-2 stack</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="STcustom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ST-logo-small.jpg"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BLE Static Stack
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Building an application separated from BlueNRG-1, BlueNRG-2 stack </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This document describes how to build a BLE demo application using the static BLE stack approach. It is possible to build a project containing the BlueNRG-1,2 stack library with all (or part) of its APIs and build a second project that does not contains the stack and nevertheless it can use it. In this way the second project, containing only the application, can be programmed into the device without reprogramming the BlueNRG-1,2 stack. <b> This is valid as long as the Bluetooth stack does not have to be changed.</b> The document content is valid for both BlueNRG-1 and BlueNRG-2 devices. Any reference to BlueNRG-1 device is also valid for the BlueNRG-2 device. Any specific difference is highlighted whenever it is needed. <br />
<br />
 Follow the list of key steps to be followed:</p>
<h1><a class="anchor" id="_1"></a>
BLE static stack description</h1>
<p>In the partitioning illustrated in <b>Figure 1:Flash memory partitioning</b>, the BLE stack is programmed in a section of the flash together with a simple reset manager. Normally this application only has the task to jump to the application code and call the service routines in the applicationâ€™s interrupt vector table once an interrupt occurs (necessary because interrupt vector table remapping is not supported in Cortex-M0). <br />
 This simple reset manager may be replaced by a more complex application, e.g. a bootloader</p>
<table  border="0">
<tr>
<th></th></tr>
<tr>
<td><div class="image">
<img src="Figure_1.png" />
</div>
   </td></tr>
<tr align="center">
<td><b style="font-size: 18px; color:blue;"> Figure 1: Flash memory partitioning </b>  </td></tr>
</table>
<p>The reset manager should not use any variable in RAM, hence the only RAM space used by the reset manager firmware is the one used by the BLE library. Part of the RAM can be reserved for special variables shared between simple and main application, e.g. to perform a software activation of a bootloader. <b>Figure 2: RAM partitioning </b> shows the RAM statically allocated by the stack (blue area). The BlueNRG stack also needs additional RAM that is provided by the application during stack initialization. This space is allocated by the application.</p>
<table  border="0">
<tr>
<th></th></tr>
<tr>
<td><div class="image">
<img src="Figure_2.png" />
</div>
   </td></tr>
<tr align="center">
<td><b style="font-size: 18px; color:blue;"> Figure 2: RAM partitioning </b>  </td></tr>
</table>
<h1><a class="anchor" id="_2"></a>
Building an application that uses the BlueNRG-1/2 Static Stack</h1>
<p>BLE_SensorDemo_with_Static_Stack is a demonstration application under Project\BLE_Examples directory. This application does not contain the Bluetooth library but uses the APIs provided by the library programmed inside the first area of the Flash.</p>
<p>In order to correctly configure a project to use the BLE static library, the symbols of the library must be taken into account by the linker during the linking process. All the pointers to the functions that are exported by the library are accessible through a table in Flash (command table) or directly, using a library containing absolute symbols (e.g. libbluenrg1_static_stack.a). The pointers to the callbacks for events generated by the library are instead stored in a table in RAM (event table), so that the application can write its own pointers into this table.</p>
<p>The libbluenrg1_static_stack.a file is generated by the BLE_Static_Stack project, so that this file can be used by application's project during linking phase to resolve all the required symbols. The bluenrg_stack_init_if.c file is used in order to automatically register all the application callbacks without taking care of explicitly register them when using the static stack library.</p>
<p>Two linker variables for the application's project need to be set to the proper values. MEMORY_FLASH_APP_OFFSET must be set to the start of the first available sector in Flash. MEMORY_RAM_APP_OFFSET must be set with an address that is equal to (or greater than) the offset of the first available RAM location. See BLE_SensorDemo_with_Static_Stack project to know which RAM offset must be used by your application when using the Static Stack included insided the BlueNRG-1 DK. When using a customized recompiled version of the static BLE library, the map file generated together with the BLE static stack library indicates which is the first RAM location that is available to the application. E.g.: </p><ul>
<li>
If static stack binary uses flash space till address 0x1005a598, MEMORY_FLASH_APP_OFFSET=0x1A800 (i.e. 0x1005a598 - 0x10040000, rounded to the start of the sector) </li>
<li>
If static stack library uses RAM till address 0x20001428, MEMORY_RAM_APP_OFFSET=0x1428 (i.e. 0x20001428 - 0x20000000) </li>
</ul>
<h2><a class="anchor" id="_2_1"></a>
Build steps</h2>
<ul>
<li>Remove libbluenrg1_stack.a library from the set of files to be compiled </li>
<li>Include bluenrg1_stack_init_if.c and one of the ".a" libraries suitable for your application (libbluenrgX_static_stack_NNN.a) in your project (from Library\Bluetooth_LE\library\static_stack). </li>
<li>Define NO_SMART_POWER_MANAGEMENT symbol for C compiler. </li>
<li>Define MEMORY_FLASH_APP_OFFSET for linker, depending on the Flash size occupied by the BlueNRG static stack image. E.g. if static stack image uses the Flash till address 0x1005a438, offset must be equal to 0x1A800, which is the offset of the first available Flash location aligned to the start of a page. </li>
<li>Define MEMORY_RAM_APP_OFFSET for linker with the offset in RAM equal to the first available address in RAM. E.g. 0x404, aligned to a 32-bit word. See MEMORY_RAM_APP_OFFSET used inside BLE_SensorDemo_Fixed_Stack project to know which RAM offset must be used by your application when using the Static Stack included insided the BlueNRG-1 DK.</li>
</ul>
<h2><a class="anchor" id="_2_2"></a>
Run steps</h2>
<ul>
<li>Load the Static Stack image based on the device type and the OTA update scenario (BLE_Static_Stack.hex or BLE_Static_Stack_OTA_BTL_ResetManager.hex). </li>
<li>Load the application built to support the static stack.</li>
</ul>
<h1><a class="anchor" id="_3"></a>
Building BlueNRG-1/2 Static Stack project</h1>
<p>The BlueNRG-1/2 static stack is provided inside the BlueNRG1-2 DK in binary format (BLE_Static_Stack.hex and BLE_Static_Stack_OTA_BTL_ResetManager.hex), ready to be programmed into the device. Usually there is no need to build it again. If you do not want to modify it, you can skip this section.</p>
<p>BLE_Static_Stack project on Project\BLE_Examples folder can be used to build a firmware that contains only the Bluetooth stack library and a reset manager. The projects for IAR Embedded Workbench for ARM, KEIL MDK-ARM and Atollic TrueSTUDIO are provided. Compared to a normal application using BlueNRG stack library, this project contains three special C files: </p><ul>
<li>
bluenrg_cmd_if.c: it defines an array that contains all the stack APIs (<em>command table</em>). </li>
<li>
bluenrg_ev_if.c: an array is defined, which is used to store the pointers to the stack callbacks (<em>event table</em>). These pointers must be provided by the application. </li>
<li>
bluenrg_it_stub.c: in this file all the interrupt service routines are defined. The correct application's interrupt service routine is called by these functions when an interrupt occurs. </li>
</ul>
<p>After the firmware is built, an external program generates a library, libbluenrg1_static_stack.a, containing the symbol table of the stack's function addresses. The pointers to the callback functions has to be stored in an array allocated in RAM (ev_call_table), whose symbol is provided in libbluenrg1_static_stack.a. Using a library containing the addresses of all the symbols allows to directly call stack's functions without accessing them through the command table (faster access and less code). <br />
 Two macros need to be changed in case the linking process fails because space is not enough, or if the space reserved for the stack becomes lower: APP_OFFSET and MEMORY_FLASH_APP_SIZE. <br />
 The preprocessor macro APP_OFFSET must be set to the offset of the first flash address of the main application. MEMORY_FLASH_APP_SIZE linker variable is used to avoid that the flash occupancy becomes higher than expected. If set it to a given value, the linker returns error if the size of the flash needed by the application is higher than the specified value. <br />
 E.g. if after the building process the first available address in Flash (rounded to the beginning of the next sector) is 0x10053000, APP_OFFSET can be set to 0x14000 (0x10053000 - 0x10040000). MEMORY_FLASH_APP_SIZE must set to 0x14000 to be sure that the building process gives error if the size of the firmware exceeds this limit. </p><ul>
<li><em> After the firmware has been built, the map file must be analyzed to take note of the last address in RAM used by the stack (except for the CSTACK block). This is important to build a working application.</em> </li>
</ul>
<h2><a class="anchor" id="_3_1"></a>
Prerequisites</h2>
<p>Install GNU ARM Embedded Toolchain and add the binary folder in the system PATH. The utility create_sym_lib.exe in BlueNRG-1 SDK Utility folder needs the following utilities: </p><ul>
<li>arm-none-eabi-readelf </li>
<li>arm-none-eabi-gcc </li>
<li>arm-none-eabi-ar</li>
</ul>
<p>Open the Windows Command Prompt and try to invoke those commands to check if they are correctly installed. </p>
<h2><a class="anchor" id="_3_2"></a>
Build steps</h2>
<ul>
<li>Build "BLE Static Stack" project. If necessary, change MEMORY_FLASH_APP_SIZE (for linker) to increase (or possibly reduce) the flash reserved for the BlueNRG Stack. </li>
<li>If MEMORY_FLASH_APP_SIZE has been changed, change also APP_OFFSET (for C preprocessor), or RESET_MANAGER_SIZE (if using the Reset Manager to support OTA firmware update). This macro points to the base of the flash where the application resides and it should be equal to MEMORY_FLASH_APP_SIZE + MEMORY_FLASH_APP_OFFSET. </li>
<li>Use create_sym_lib.exe utility to generate the required library with symbols to be referenced by the application. This is done as a post-build task in BLE Static Stack project. </li>
<li>Take a note of the first available address in RAM (excluding CSTACK) from map file. (e.g. 0x20000404). It has to be used when defining MEMORY_RAM_APP_OFFSET inside application project. </li>
</ul>
<h1><a class="anchor" id="_4"></a>
Using a bootloader</h1>
<ul>
<li>When the application needs a second level bootloader (1) , the best solution is to place the bootloader at the beginning of the Flash. In this case the stack library must be allocated starting at a given offset inside the Flash. The offset can be provided to the linker through the MEMORY_FLASH_APP_OFFSET variable. </li>
<li>E.g., if the bootloader occupies the first two sectors of the Flash, MEMORY_FLASH_APP_OFFSET must be set to 0x1000.</li>
</ul>
<ul>
<li>(1) First level bootloader is in ROM and accessible through UART interface.</li>
</ul>
<table  border="0">
<tr>
<th></th></tr>
<tr>
<td><div class="image">
<img src="Figure_3.png" />
</div>
   </td></tr>
<tr align="center">
<td><b style="font-size: 18px; color:blue;"> Figure 3: Stack allocation in Flash with offset </b>  </td></tr>
</table>
<h1><a class="anchor" id="_5"></a>
Sleep management and context save/restore</h1>
<ul>
<li>In the example projects, the functions handling the sleep mode are kept inside application firmware. Context save before going to sleep is also done by the application. Instead, context restore is performed by the first firmware that is executed after exiting from sleep mode, i.e. the reset manager built with the fixed stack, or the bootloader if present. This allow to restore the context with minimum delay and to use as less memory stack as possible (2). Since the context restore is not performed by the application, the code can be excluded by defining the NO_SMART_POWER_MANAGEMENT macro.</li>
</ul>
<ul>
<li>(2) Since functions may use memory stack, calling functions before context is restored may dirty the memory stack. For this purpose, the function handling the entrance and exit from the sleep mode saves and restores the firsts words of the memory stack which may have been corrupted by the execution of the code before the context restore.</li>
</ul>
<h1><a class="anchor" id="_6"></a>
Support to OTA firmware update</h1>
<p>It is possible to upgrade only the application firmware over-the-air if the application has the support to the OTA Service Manager. It is also required that the Static Stack is built with a Reset Manager which is able to deal with a "dual firmware" approach. The application area is divided in two sections: the lower part and the higher part.</p>
<p>The example projects includes configurations to support firmware upgrade over-the-air. When using this configuration, the application must link a specific library (libbluenrgX_static_stack_with_resetmanager.a), which has been created including the OTA update reset manager.</p>
<p>The difference with respect to the basic configuration are: </p><ul>
<li>Linker macro RESET_MANAGER_SIZE is used instead of MEMORY_FLASH_APP_OFFSET. </li>
<li>Linker macro ST_OTA_LOWER_APPLICATION or ST_OTA_HIGHER_APPLICATION must be used to distinguish between "lower app" and "higher app" builds. Together with MEMORY_FLASH_APP_OFFSET It is necessary to the linker to place the code in the the correct Flash area. </li>
<li>C preprocessor macro RESET_MANAGER_SIZE has to be defined for the OTA update library. </li>
</ul>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Copyright &copy; 2021 by STMicrolectronics. All rights reserved.<br>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
